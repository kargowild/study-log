# 가장 많이 사용된 회의실

현수가 다니는 회사에서 여러개의 회의가 동시에 진행되는 행사를 기획하고 있습니다.  
현수의 회사는 0번부터 n-1번으로 번호가 매겨진 회의실을 n개 가지고 있습니다.

각 회의는 다음과 같은 방식으로 회의실에 할당됩니다.

1) 사용 가능한 회의실이 생기면 시작 시간이 더 빠른 회의로 회의실에 배정합니다.
2) 사용 가능한 회의실이 여러개일 경우 가장 번호가 낮은 회의실에 회의를 배정합니다.
3) 사용 가능한 회의실이 없는 경우 다음 순서의 회의는 회의실이 비워질 때까지 기다렸다  
   자신의 회의 시간만큼 회의를 합니다. 만약 회의가 7시에 끝나고 회의실이 7시에 비워졌다면 다른 회의가 바로 7시에 시작될 수 있다고 가정합니다.

매개변수 n에 회의실의 개수가 주어지고, 매개변수 meetings에 각 회의의 시작시간과 끝나는 시간이 주어졌을 때 가장 많은 회의를 개최한 회의실의 번호를 반환합니다.  
답이 여러개일 경우 번호가 가장 작은 회의실의 번호를 반환합니다.

---

### 입력값 예

| n | meetings                                                                 | answer |
|---|--------------------------------------------------------------------------|--------|
| 2 | [[0, 5], [2, 7], [4, 5], [5, 6], [7, 10], [9, 12]]                        | 0      |
| 3 | [[3, 9], [1, 10], [5, 8], [10, 15], [9, 14], [12, 14], [15, 20]]          | 1      |
| 3 | [[1, 30], [2, 15], [3, 10], [4, 12], [6, 10]]                             | 1      |
| 4 | [[3, 20], [1, 25], [5, 8], [10, 15], [9, 14], [12, 14], [15, 20]]         | 2      |

---

### 제약사항

- `meetings`의 길이는 200,000입니다. 각 회의의 시작시간은 고유합니다.
- `1 <= n <= 200`
- `회의시간은 0 < 회의시간 <= 500,000입니다.`

---

### 예제 1번 설명

- [0, 5] 회의가 0번 회의실에 배정됩니다.
- [2, 7] 회의가 1번 회의실에 배정됩니다.
- [4, 5] 회의는 기다렸다 [0, 5] 회의가 끝나고 [5, 6] 동안 회의를 0번 회의실에서 합니다.
- [7, 10] 회의는 0번, 1번 회의실 모두 사용할 수 있지만 이 경우 0번 회의실에 배정됩니다.
- [9, 12] 회의는 1번 회의실에 배정됩니다.

0번은 3개의 회의를 개최하고, 1번은 2개의 회의를 개최합니다.  
답은 0번 회의실입니다.


# 풀이
- 다음에 PQ 써서 다시 풀어보자!
- 회의실 갯수가 많지 않아서 200개에 대해서 매번 for loop를 돌아도 되지 않을까 싶어서 배열로 간단히 풀었는데, 타임리밋 나려나 모르겠네.
- 강의 보니까 PQ를 써야한다네. 
  - 나도 처음에 PQ를 쓰려했는데, PQ 정렬 기준 선택이 어려워서 선회했음.
  - 선택 가능한 회의실들 중 번호가 작은 걸 우선순위로 해야하는데, 선택 가능한 회의실이 없는 경우에는 끝나는 시간이 우선순위가 되면서 복잡함.. 어떻게 하는거지?
- 강사님 풀이
  - 빈 회의실을 넣어놓는 TreeSet 1개 (rooms) -> TreeSet은 레드블랙트리로 구현된다. -> 여기서도 걍 PQ 쓰면 안 되나? 
  - 현재 사용 중인 회의실을 넣어놓는 PQ 1개 (회의가 끝나는 시간 순서로 정렬해야 하고, 회의 번호를 가지고 있어야 한다.)
  - 회의를 처리하기 전에, PQ를 보면서 회의 시작 시간보다 먼저 끝나는 작업들은 다 빼서 rooms에 넣는다.  
```java
import java.util.*;
class Solution {
    public int solution(int n, int[][] meetings){
        int answer = 0;

        for (int[] meeting : meetings) {
            meeting[1] = meeting[1] - meeting[0];
        }
        Arrays.sort(meetings, (a, b) -> a[0] - b[0]); // 시작시간 기준 정렬

        int[] ends = new int[n];
        int[] counts = new int[n];

        for (int[] meeting : meetings) {
            // 사용 가능한 방 번호 찾기. 사용 가능한 방이 없다면, 가장 빨리 끝나는 방 찾기. 둘 다 방번호 순서대로
            int start = meeting[0];
            int need = meeting[1];

            int select = 0;
            int minEnd = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                if (ends[i] <= start) {
                    select = i;
                    break;
                }
                if (ends[i] < minEnd) {
                    minEnd = ends[i];
                    select = i;
                }
            }

            counts[select] += 1;
            
            // 아래와 같이 구해야 하는데, 
            if (start > ends[select]) {
                ends[select] = start + need;
            } else {
                ends[select] += need;
            }
            
            // 처음에 이런 식으로 구해버려서 값이 너무 크게 증가해버렸다... 이 부분 디버깅하기 어려웠음. +=을 사용할 때는 좀 더 주의해야겠다.
            // ends[select] += Math.max(start, ends[select]) + need;
        }

        int max = 0;
        for (int i = 0; i < n; i++) {
            if (counts[i] > max) {
                answer = i;
                max = counts[i];
            }
        }
        
        return answer;
    }

    public static void main(String[] args){
        Solution T = new Solution();
        System.out.println(T.solution(2, new int[][]{{0, 5}, {2, 7}, {4, 5}, {7, 10}, {9, 12}}));
        System.out.println(T.solution(3, new int[][]{{3, 9}, {1, 10}, {5, 8}, {10, 15}, {9, 14}, {12, 14}, {15, 20}}));
        System.out.println(T.solution(3, new int[][]{{1, 30}, {2, 15}, {3, 10}, {4, 12}, {6, 10}}));
        System.out.println(T.solution(4, new int[][]{{3, 20}, {1, 25}, {5, 8}, {10, 15}, {9, 14}, {12, 14}, {15, 20}}));
    }
}

```
